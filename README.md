# CustomSTL_C

**Version: 1.0.0-beta**

**CustomSTL** is a **C** library project that implements core features of the C++ Standard Template Library (STL).  
It provides equivalent functionality for common data structures and algorithms, making it easier to learn, compare and explore STL concepts in a pure **C** environment.

---

## Contents

<details>
<summary><b>Highlights</b></summary>

- Custom STL containers and algorithms have similar functionality to the ones provided by C++ STL standard library.
- Fully type-safe – Templates ensure strict type correctness, avoiding unsafe casting between container types or elements.
- Automatic memory management – Elements are automatically managed and destroyed via default or user-provided functions.
- Consistent, easy-to-learn API – Container and algorithm usage follows a uniform design similar to C++ STL. Simply include the headers.
- No callback functions - Template behavior is achieved via macros. That allows functions to be executed directly, avoiding the overhead of stored callback functions.
- Well-tested – The project includes unit tests and builds the corresponding test executables.

</details>
<!-- END Highlights -->

<details>
<summary><b>Usage</b></summary>

STL C library - the user must declare the desired container or functions via macros and provide a custom name prefix and the desired type.  
Some containers may need additional parameters (e.g. `c_priority_queue.h` needs a function to compare values).  

For common types and pointers is required to use this macro before any other STL definition in order to define basic memory management behavior and operations:
- `DEFINE_DEFAULT_TYPE_PUBLIC_MEMBERS`  

```C
#include "custom/c_priority_queue.h"

DEFINE_DEFAULT_TYPE_PUBLIC_MEMBERS(unsigned int, myuint_t)      // myuint_t is the typedef alias for desired type (use it in container definition)
DEFINE_GENERIC_PRIORITY_QUEUE(UIntPQ, myuint_t, myuint_t_less)  // myuint_t_less was generated by previous macro

int main()
{
    UIntPQ myUIntPQInstance = UIntPQ_create();

    myuint_t val;

    val = 1;
    UIntPQ_insert(&myUIntPQInstance, &val);

    val = 0;
    UIntPQ_insert(&myUIntPQInstance, &val);

    val = 2;
    UIntPQ_insert(&myUIntPQInstance, &val);

    while (!UIntPQ_empty(&myUIntPQInstance))
    {
      printf("Value: %d\n", *UIntPQ_peek(&myUIntPQInstance));
      UIntPQ_pop(&myUIntPQInstance);
    }

    UIntPQ_destroy(&myUIntPQInstance);

    return 0;
}

// Prints:
// Value: 0
// Value: 1
// Value: 2

```

For custom structures is required to use the following macros in order to define custom memory management behavior:
- `DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_CREATE`
- `DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_DESTROY`
- `DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_COPY`
- `DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_MOVE`
- `DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_EQUALS`

```C
#include "custom/c_vector.h"

// define custom struct
typedef struct
{
    int a;
    int* b;
} MyStruct;

// define custom memory management behavior

// custom create
DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_CREATE(MyStruct)
{
    return (MyStruct){
        .a = 0,
        .b = NULL
    };
}

// custom destroy
DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_DESTROY(MyStruct)
{
    if (target->b)
        free(target->b);
}

// custom copy
DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_COPY(MyStruct)
{
    if (dest == source) return;

    dest->a = source->a;

    if (dest->b)
        free(dest->b);

    if (source->b)
    {
        dest->b = (int*)malloc(sizeof(int));
        *dest->b = *source->b;
    }
    else
        dest->b = NULL;
}

// custom move
DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_MOVE(MyStruct)
{
    if (dest == source) return;

    *dest = *source;
    source->a = 0;
    source->b = NULL;
}

// custom equals
DECLARE_CUSTOM_TYPE_PUBLIC_MEMBER_EQUALS(MyStruct)
{
    return left->a == right->a && left->b == right->b;
}

// define the vector for the struct
DEFINE_GENERIC_VECTOR(MyStructVector, MyStruct)

int main()
{
    MyStructVector vec = MyStructVector_create();

    MyStruct s1 = MyStruct_create();
    s1.a = 1;

    MyStruct s2 = MyStruct_create();
    s2.a = 2;

    MyStruct s3 = MyStruct_create();
    s3.a = 3;

    MyStructVector_push_back(&vec, &s1);
    MyStructVector_push_back(&vec, &s2);
    MyStructVector_push_back(&vec, &s3);

    while (!MyStructVector_empty(&vec))
    {
        printf("Value: %d\n", MyStructVector_element_back(&vec)->a);
        MyStructVector_pop_back(&vec);
    }

    MyStructVector_destroy(&vec);
    MyStruct_destroy(&s1);
    MyStruct_destroy(&s2);
    MyStruct_destroy(&s3);

    return 0;
}

// Prints:
// Value: 3
// Value: 2
// Value: 1

```

</details>
<!-- END Usage -->

<details>
<summary><b>Headers</b></summary>

- `c_list` - `c_vector` - `c_queue` - `c_priority_queue` - `c_stack` - `c_pair`
- `c_utility`

</details>
<!-- END C Headers -->

---

## Requirements

- **C Compiler**: C99 compliant
- **Build System**: CMake (≥ 3.22.1), Ninja  
- **Testing Frameworks**:   
  - [Unity](https://github.com/ThrowTheSwitch/Unity) (auto fetched via CMake)  

---

## Installation & Build

```bash
# Clone the repository
git clone https://github.com/ToneGabriel/CustomSTL_C.git
cd CustomSTL_C

# Create a build directory
cmake -G "Ninja" -B build

# Build the project
cmake --build build

# Run tests
ctest --test-dir build
```

Or simply run the script `scripts/RUN_TESTS` and the build is done automatically.   
The results can be found in `build/Testing/Temporary` folder.
